=== ФУНКЦИЯ KILL ===

ОПРЕДЕЛЕНИЕ:
Функция kill() используется для отправки сигнала процессу или группе процессов.

СИНТАКСИС:
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);

ПАРАМЕТРЫ:
- pid: идентификатор процесса-получателя
  * pid > 0  - сигнал отправляется процессу с указанным PID
  * pid == 0 - сигнал отправляется всем процессам в группе текущего процесса
  * pid == -1 - сигнал отправляется всем процессам, кроме специальных системных
  * pid < -1 - сигнал отправляется всем процессам в группе |pid|

- sig: номер сигнала для отправки
  * SIGTERM (15) - "вежливый" запрос на завершение
  * SIGKILL (9)  - немедленное уничтожение процесса
  * SIGUSR1 (10) - пользовательский сигнал 1
  * SIGUSR2 (12) - пользовательский сигнал 2

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
- 0  - успех
- -1 - ошибка (errno устанавливается соответствующим образом)

ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ:
// Попросить процесс 1234 завершиться
kill(1234, SIGTERM);

// Немедленно убить процесс 5678
kill(5678, SIGKILL);

// Проверить существование процесса
if (kill(9999, 0) == 0) {
    printf("Процесс 9999 существует\n");
}

ОШИБКИ:
- EPERM  - нет прав для отправки сигнала
- ESRCH  - процесс не существует
- EINVAL - неверный номер сигнала

=== НЕБЛОКИРУЮЩИЙ WAIT С WNOHANG ===

ОПРЕДЕЛЕНИЕ:

waitpid() - системный вызов для ожидания изменения состояния дочернего процесса.

Флаг WNOHANG делает вызов waitpid() неблокирующим - функция немедленно
возвращается, даже если дочерние процессы еще не завершились.

СИНТАКСИС:
#include <sys/wait.h>
pid_t waitpid(pid_t pid, int *wstatus, int options);

ПАРАМЕТРЫ:
- pid: идентификатор процесса
  * -1 - ожидать любого дочернего процесса
  * >0 - ожидать конкретный процесс

- wstatus: указатель для сохранения статуса завершения

- options: флаги поведения
  * WNOHANG - немедленно возвращаться, если нет завершившихся процессов
  * WUNTRACED - также возвращаться для остановленных процессов
  * WCONTINUED - также возвращаться для продолженных процессов

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ С WNOHANG:
- >0 - PID завершившегося дочернего процесса
- 0  - нет завершившихся процессов (не блокировать!)
- -1 - ошибка

ПРИМЕР ИСПОЛЬЗОВАНИЯ:
int active_children = 3;
while (active_children > 0) {
    int status;
    pid_t child_pid = waitpid(-1, &status, WNOHANG);
    
    if (child_pid > 0) {
        // Найден завершившийся процесс
        active_children--;
        printf("Процесс %d завершился\n", child_pid);
    } else if (child_pid == 0) {
        // Процессы еще работают, можно делать другую работу
        printf("Дочерние процессы еще работают...\n");
        sleep(1);
    } else {
        // Ошибка
        perror("waitpid");
        break;
    }
}

ПРЕИМУЩЕСТВА WNOHANG:
1. Не блокирует выполнение родительского процесса
2. Позволяет обрабатывать другие события во время ожидания
3. Можно реализовать таймауты для ожидания
4. Родитель может продолжать свою основную работу

=== ФУНКЦИЯ ALARM, СИГНАЛ SIGALRM, ФУНКЦИЯ SIGNAL ===

ФУНКЦИЯ ALARM:
ОПРЕДЕЛЕНИЕ:
Устанавливает таймер, который отправляет сигнал SIGALRM через заданное время.

СИНТАКСИС:
#include <unistd.h>
unsigned int alarm(unsigned int seconds);

ПАРАМЕТРЫ:
- seconds: время в секундах до отправки SIGALRM

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
- Количество секунд до срабатывания предыдущего будильника
- 0, если предыдущий будильник не был установлен

ОСОБЕННОСТИ:
- Таймер работает в реальном времени (не CPU время)
- Можно установить только один будильник на процесс
- alarm(0) отменяет установленный будильник

ПРИМЕРЫ:
// Установить будильник на 5 секунд
alarm(5);

// Отменить будильник
alarm(0);

// Получить оставшееся время
unsigned int remaining = alarm(10);
// ... через некоторое время
remaining = alarm(0); // отменить и получить оставшееся время

СИГНАЛ SIGALRM:
ОПРЕДЕЛЕНИЕ:
Сигнал, отправляемый процессу при срабатывании будильника, установленного alarm().

ХАРАКТЕРИСТИКИ:
- Номер сигнала: 14
- Действие по умолчанию: завершение процесса
- Не может быть проигнорирован или заблокирован (в некоторых системах)
- Используется для реализации таймаутов

ФУНКЦИЯ SIGNAL:
ОПРЕДЕЛЕНИЕ:
Устанавливает обработчик для указанного сигнала.

СИНТАКСИС:
#include <signal.h>
void (*signal(int sig, void (*func)(int)))(int);

АЛЬТЕРНАТИВНЫЙ СИНТАКСИС:
typedef void (*sighandler_t)(int);
sighandler_t signal(int sig, sighandler_t handler);

ПАРАМЕТРЫ:
- sig: номер сигнала (SIGALRM, SIGINT, SIGTERM, etc.)
- handler: указатель на функцию-обработчик или специальное значение

ЗНАЧЕНИЯ HANDLER:
- SIG_DFL - восстановить поведение по умолчанию
- SIG_IGN - игнорировать сигнал
- address - адрес пользовательской функции-обработчика

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ:
- Предыдущий обработчик сигнала
- SIG_ERR в случае ошибки

ПРИМЕР ПОЛНОЙ ПРОГРАММЫ С ТАЙМАУТОМ:
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

void timeout_handler(int sig) {
    printf("Время вышло! Отправляю SIGKILL дочерним процессам.\n");
    // Здесь можно убить дочерние процессы
}

int main() {
    // Установить обработчик для SIGALRM
    if (signal(SIGALRM, timeout_handler) == SIG_ERR) {
        perror("Ошибка установки обработчика сигнала");
        return 1;
    }

    printf("Устанавливаю таймаут на 3 секунды\n");
    alarm(3);  // Будильник сработает через 3 секунды

    // Имитация долгой работы
    printf("Начинаю долгую работу...\n");
    for (int i = 1; i <= 5; i++) {
        printf("Работаю %d/5...\n", i);
        sleep(1);
    }

    // Отменить будильник, если работа завершилась вовремя
    alarm(0);
    printf("Работа завершена успешно!\n");

    return 0;
}

ПРАКТИЧЕСКОЕ ПРИМЕНЕНИЕ В КОМБИНАЦИИ:

1. РЕАЛИЗАЦИЯ ТАЙМАУТОВ:
   - Установить обработчик SIGALRM
   - Вызвать alarm(timeout)
   - Выполнить операцию
   - Если сработал SIGALRM - операция превысила таймаут

2. УПРАВЛЕНИЕ ПРОЦЕССАМИ:
   - Родитель устанавливает таймаут
   - Если дочерние процессы не завершаются вовремя
   - Отправляет им kill(pid, SIGKILL)

3. ПЕРИОДИЧЕСКИЕ ДЕЙСТВИЯ:
   - В обработчике SIGALRM выполнить действие
   - Установить будильник снова

ВАЖНЫЕ ЗАМЕЧАНИЯ:

1. Функция signal() считается устаревшей, рекомендуется использовать sigaction()
2. SIGALRM не должен использоваться для точного измерения времени
3. При использовании fork() будильник наследуется дочерними процессами
4. При использовании exec() все ожидающие сигналы сбрасываются

АЛЬТЕРНАТИВЫ:
- Для более точных таймеров: setitimer()
- Для более надежной обработки сигналов: sigaction()
- Для многопоточных приложений: timer_create()